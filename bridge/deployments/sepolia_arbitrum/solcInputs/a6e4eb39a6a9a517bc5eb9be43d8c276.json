{
  "language": "Solidity",
  "sources": {
    "contracts/Bridge/Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n// import \"hardhat/console.sol\";\n// Import base Initializable contract\nimport \"../zeppelin/upgradable/Initializable.sol\";\n// Import interface and library from OpenZeppelin contracts\nimport \"../zeppelin/upgradable/utils/ReentrancyGuard.sol\";\nimport \"../zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\n\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\nimport \"../zeppelin/token/ERC20/SafeERC20.sol\";\nimport \"../zeppelin/utils/Address.sol\";\nimport \"../zeppelin/math/SafeMath.sol\";\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\n\nimport \"../lib/LibEIP712.sol\";\nimport \"../lib/LibUtils.sol\";\n\nimport \"../interface/IBridge.sol\";\nimport \"../interface/ISideToken.sol\";\nimport \"../interface/ISideTokenFactory.sol\";\nimport \"../interface/IAllowTokens.sol\";\nimport \"../interface/IWrapped.sol\";\n\n// solhint-disable-next-line max-states-count\ncontract Bridge is Initializable, IBridge, IERC777Recipient, UpgradablePausable, UpgradableOwnable, ReentrancyGuard {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing Address for address;\n\n\taddress constant internal NULL_ADDRESS = address(0);\n\taddress constant internal DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\tbytes32 constant internal NULL_HASH = bytes32(0);\n\tIERC1820Registry constant internal ERC1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n\taddress internal federation;\n\tuint256 internal feePercentage;\n\tstring public deprecatedSymbolPrefix;\n\t// domainSeparator replaces uint256 internal _depprecatedLastDay;\n\tbytes32 public domainSeparator;\n\tuint256 internal _deprecatedSpentToday;\n\n\tmapping (address => address) public deprecatedMappedTokens; // OriginalToken => SideToken\n\tmapping (address => address) public deprecatedOriginalTokens; // SideToken => OriginalToken\n\tmapping (address => bool) public deprecatedKnownTokens; // OriginalToken => true\n\t\n\t// claimed can use the same of bytes32\n\tmapping (bytes32 => bool) public claimed; // transactionDataHash => true // previously named processed\n\n\tIAllowTokens public allowTokens;\n\tISideTokenFactory public sideTokenFactory;\n\t//Bridge_v1 variables\n\tbool public isUpgrading;\n\t// Percentage with up to 2 decimals\n\tuint256 constant public feePercentageDivider = 10000; // solhint-disable-line const-name-snakecase\n\t//Bridge_v2 variables\n\tbytes32 constant internal _erc777Interface = keccak256(\"ERC777Token\"); // solhint-disable-line const-name-snakecase\n\tIWrapped public wrappedCurrency;\n\tmapping (bytes32 => bytes32) public transactionsDataHashes; // transactionHash => transactionDataHash\n\tmapping (bytes32 => address) public originalTokenAddresses; // transactionHash => originalTokenAddress\n\tmapping (bytes32 => address) public senderAddresses; // transactionHash => senderAddress\n\n\t// keccak256(\"Claim(address to,uint256 amount,bytes32 transactionHash,uint256 originChainId,address relayer,uint256 fee,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant CLAIM_TYPEHASH = 0xaf3ac34fea9cc1b1def33a9bdc482d988feb61b5015ae4a55e2a62bb3600d54c;\n\tmapping(address => uint) public nonces;\n\n\t//Bridge_v3 variables multichain\n\tmapping (uint256 => mapping(address => address)) public sideTokenByOriginalTokenByChain; // chainId => OriginalToken Address => SideToken Address\n\tmapping (address => OriginalToken) public originalTokenBySideToken; // SideTokenAddress => struct {}\n\tmapping (uint256 => mapping(address => bool)) public knownTokenByChain; // chainId => OriginalToken Address => Know\n\tmapping (address => string) public EvmToHathorTokenMap;\n\tmapping (string => OriginalToken) public HathorToEvmTokenMap;\t\n\tbool public initiated;\n\n\tevent AllowTokensChanged(address _newAllowTokens);\n\tevent FederationChanged(address _newFederation);\n\tevent SideTokenFactoryChanged(address _newSideTokenFactory);\n\tevent Upgrading(bool _isUpgrading);\n\tevent WrappedCurrencyChanged(address _wrappedCurrency);\n\tevent HathorTokenMapped(address token, string uid);\n\tevent SideTokenMapped(uint256 chainId, address originalToken, address sideToken);\n\n\tfunction initialize(\n\t\taddress _manager,\n\t\taddress _federation,\n\t\taddress _allowTokens,\n\t\taddress _sideTokenFactory\n\t) public initializer {\n\t\tUpgradableOwnable.initialize(_manager);\n\t\tUpgradablePausable.__Pausable_init(_manager);\n\t\tallowTokens = IAllowTokens(_allowTokens);\n\t\tsideTokenFactory = ISideTokenFactory(_sideTokenFactory);\n\t\tfederation = _federation;\n\t\t//keccak256(\"ERC777TokensRecipient\")\n\t\tERC1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\n\t\tinitDomainSeparator();\n\t}\n\n\treceive () external payable {\n\t\t// The fallback function is needed to use WRBTC\n\t\trequire(_msgSender() == address(wrappedCurrency), \"Bridge: not wrappedCurrency\");\n\t}\n\n\tfunction version() override external pure returns (string memory) {\n\t\treturn \"v4\";\n\t}\n\n\tfunction initDomainSeparator() public {\n\t\trequire( !initiated, \"Bridge: already initiated\");\n\t\tdomainSeparator = LibEIP712.hashEIP712Domain(\n\t\t\t\"Hathor Token Bridge\",\n\t\t\t\"1\",\n\t\t\tblock.chainid,\n\t\t\taddress(this)\n\t\t);\n\t\tinitiated == true;\n\t}\n\n\tmodifier whenNotUpgrading() {\n\t\trequire(!isUpgrading, \"Bridge: Upgrading\");\n\t\t_;\n\t}\n\n\tfunction shouldBeCurrentChainId(uint256 chainId) internal view {\n\t\trequire(chainId == block.chainid, \"Bridge: Not block.chainid\");\n\t}\n\n\tfunction sideTokenByOriginalToken(uint256 chainId, address originalToken) public view returns(address) {\n\t\trequire(originalToken != NULL_ADDRESS, \"Bridge: Null token\");\n\t\trequire(originalToken != DEAD_ADDRESS, \"Bridge: Dead token\");\n\t\taddress sideTokenAddr = sideTokenByOriginalTokenByChain[chainId][originalToken];\n\n\t\tif (sideTokenAddr != NULL_ADDRESS) {\n\t\t\treturn sideTokenAddr;\n\t\t}\n\n\t\t// specification for retrocompatibility\n\t\treturn deprecatedMappedTokens[originalToken];\n\t}\n\n\tfunction setSideTokenByOriginalAddressByChain(uint256 chainId, address originalToken, address sideToken) public onlyOwner {\n\t\trequire(originalToken != NULL_ADDRESS, \"Bridge: Null token\");\n\t\trequire(originalToken != DEAD_ADDRESS, \"Bridge: Dead token\");\n\t\tsideTokenByOriginalTokenByChain[chainId][originalToken] = sideToken;\n\t\temit SideTokenMapped(chainId, originalToken, sideToken);\n\t}\n\n\tfunction getOriginalTokenBySideToken(address sideToken) public view returns(OriginalToken memory originalToken) {\n\t\trequire(sideToken != NULL_ADDRESS, \"Bridge: Null token\");\n\t\trequire(sideToken != DEAD_ADDRESS, \"Bridge: Dead token\");\n\t\toriginalToken = originalTokenBySideToken[sideToken];\n\t\tif (originalToken.tokenAddress != NULL_ADDRESS) {\n\t\t\treturn originalToken;\n\t\t}\n\n\t\t// specification for retrocompatibility\n\t\toriginalToken.originChainId = 1; // ethereum main chain id\n\t\toriginalToken.tokenAddress = deprecatedOriginalTokens[sideToken];\n\t\treturn originalToken;\n\t}\n\n\tfunction setOriginalTokenBySideTokenByChain(address sideToken, OriginalToken memory originalToken) public onlyOwner {\n\t\trequire(sideToken != NULL_ADDRESS, \"Bridge: Null token\");\n\t\trequire(sideToken != DEAD_ADDRESS, \"Bridge: Dead token\");\n\t\toriginalTokenBySideToken[sideToken] = originalToken;\n\t\temit SideTokenMapped(originalToken.originChainId, originalToken.tokenAddress, sideToken);\n\t}\n\n\tfunction knownToken(uint256 chainId, address originalToken) public view returns(bool) {\n\t\tbool knowToken = knownTokenByChain[chainId][originalToken];\n\t\tif (knowToken) {\n\t\t\treturn knowToken;\n\t\t}\n\n\t\t// specification for retrocompatibility\n\t\treturn deprecatedKnownTokens[originalToken];\n\t}\n\n\tfunction _setKnownTokenByChain(uint256 chainId, address originalToken, bool knownTokenValue) internal {\n\t\tknownTokenByChain[chainId][originalToken] = knownTokenValue;\n\t}\n\n\tfunction acceptTransfer(\n\t\taddress _originalTokenAddress,\n\t\taddress payable _from,\n\t\taddress payable _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256\t_destinationChainId\n\t) external whenNotPaused nonReentrant override {\n\t\trequire(_msgSender() == federation, \"Bridge: Not Federation\");\n\t\tcheckChainId(_originChainId);\n\t\tshouldBeCurrentChainId(_destinationChainId);\n\t\trequire(knownToken(_originChainId, _originalTokenAddress) ||\n\t\t\tsideTokenByOriginalToken(_originChainId, _originalTokenAddress) != NULL_ADDRESS,\n\t\t\t\"Bridge: Unknown token\"\n\t\t);\n\t\trequire(_to != NULL_ADDRESS, \"Bridge: Null To\");\n\t\trequire(_amount > 0, \"Bridge: Amount 0\");\n\t\trequire(_blockHash != NULL_HASH, \"Bridge: Null BlockHash\");\n\t\trequire(_transactionHash != NULL_HASH, \"Bridge: Null TxHash\");\n\t\trequire(transactionsDataHashes[_transactionHash] == bytes32(0), \"Bridge: Already accepted\");\n\n\t\tbytes32 _transactionDataHash = getTransactionDataHash(\n\t\t\t_to,\n\t\t\t_amount,\n\t\t\t_blockHash,\n\t\t\t_transactionHash,\n\t\t\t_logIndex\n\t\t);\n\n\t\tbytes32 _transactionDataHashMultichain = getTransactionDataHash(\n\t\t\t_to,\n\t\t\t_amount,\n\t\t\t_blockHash,\n\t\t\t_transactionHash,\n\t\t\t_logIndex,\n\t\t\t_originChainId,\n\t\t\t_destinationChainId\n\t\t);\n\t\t// Do not remove, claimed also has the previously processed using the older bridge version\n\t\t// https://github.com/rsksmart/tokenbridge/blob/TOKENBRIDGE-1.2.0/bridge/contracts/Bridge.sol#L41\n\t\trequire(!isClaimed(_transactionDataHash, _transactionDataHashMultichain), \"Bridge: Already claimed\");\n\n\t\ttransactionsDataHashes[_transactionHash] = _transactionDataHashMultichain;\n\t\toriginalTokenAddresses[_transactionHash] = _originalTokenAddress;\n\t\tsenderAddresses[_transactionHash] = _from;\n\n\t\temit AcceptedCrossTransfer(\n\t\t\t_transactionHash,\n\t\t\t_originalTokenAddress,\n\t\t\t_to,\n\t\t\t_from,\n\t\t\t_amount,\n\t\t\t_blockHash,\n\t\t\t_logIndex,\n\t\t\t_originChainId,\n\t\t\t_destinationChainId\n\t\t);\n\t}\n\n\tfunction checkChainId(uint256 chainId) internal pure {\n\t\trequire(chainId > 0, \"Bridge: ChainId is 0\");\n\t}\n\n\tfunction _createSideToken(\n\t\tuint256 _typeId,\n\t\taddress _originalTokenAddress,\n\t\tuint8 _originalTokenDecimals,\n\t\tstring calldata _tokenSymbol,\n\t\tstring calldata _tokenName,\n\t\tuint256 _originChainId\n\t) internal {\n\t\trequire(_originalTokenAddress != NULL_ADDRESS, \"Bridge: Null token\");\n\t\tcheckChainId(_originChainId);\n\t\taddress sideToken = sideTokenByOriginalToken(_originChainId, _originalTokenAddress);\n\t\trequire(sideToken == NULL_ADDRESS, \"Bridge: Already exists\");\n\n\t\tuint256 granularity = LibUtils.decimalsToGranularity(_originalTokenDecimals);\n\n\t\t// Create side token\n\t\tsideToken = sideTokenFactory.createSideToken(_tokenName, _tokenSymbol, granularity);\n\n\t\tsetSideTokenByOriginalAddressByChain(_originChainId, _originalTokenAddress, sideToken);\n\n\t\tOriginalToken memory originalToken;\n\t\toriginalToken.originChainId = _originChainId;\n\t\toriginalToken.tokenAddress = _originalTokenAddress;\n\t\tsetOriginalTokenBySideTokenByChain(sideToken, originalToken);\n\t\tallowTokens.setToken(sideToken, _typeId);\n\n\t\temit NewSideToken(sideToken, _originalTokenAddress, _tokenSymbol, granularity, _originChainId);\n\t}\n\n\tfunction createSideToken(\n\t\tuint256 _typeId,\n\t\taddress _originalTokenAddress,\n\t\tuint8 _originalTokenDecimals,\n\t\tstring calldata _tokenSymbol,\n\t\tstring calldata _tokenName,\n\t\tuint256 _originChainId\n\t) external onlyOwner override {\n\t\t_createSideToken(\n\t\t\t_typeId,\n\t\t\t_originalTokenAddress,\n\t\t\t_originalTokenDecimals,\n\t\t\t_tokenSymbol,\n\t\t\t_tokenName,\n\t\t\t_originChainId\n\t\t);\n\t}\n\n\tfunction createMultipleSideTokens(\n\t\tCreateSideTokenStruct[] calldata createSideTokenStruct\n\t) external onlyOwner {\n\t\tfor(uint256 i = 0; i < createSideTokenStruct.length; i++) {\n\t\t\t_createSideToken(\n\t\t\t\tcreateSideTokenStruct[i]._typeId,\n\t\t\t\tcreateSideTokenStruct[i]._originalTokenAddress,\n\t\t\t\tcreateSideTokenStruct[i]._originalTokenDecimals,\n\t\t\t\tcreateSideTokenStruct[i]._originalTokenSymbol,\n\t\t\t\tcreateSideTokenStruct[i]._originalTokenName,\n\t\t\t\tcreateSideTokenStruct[i]._originChainId\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction claim(ClaimData calldata _claimData) external override returns (uint256 receivedAmount) {\n\t\treceivedAmount = _claim(\n\t\t\t_claimData,\n\t\t\t_claimData.to,\n\t\t\tpayable(address(0)),\n\t\t\t0\n\t\t);\n\t\treturn receivedAmount;\n\t}\n\n\tfunction claimFallback(ClaimData calldata _claimData) external override returns (uint256 receivedAmount) {\n\t\trequire(_msgSender() == senderAddresses[_claimData.transactionHash],\"Bridge: invalid sender\");\n\t\treceivedAmount = _claim(\n\t\t\t_claimData,\n\t\t\t_msgSender(),\n\t\t\tpayable(address(0)),\n\t\t\t0\n\t\t);\n\t\treturn receivedAmount;\n\t}\n\n\tfunction getDigest(\n\t\tClaimData memory _claimData,\n\t\taddress payable _relayer,\n\t\tuint256 _fee,\n\t\tuint256 _deadline\n\t) internal returns (bytes32) {\n\t\treturn LibEIP712.hashEIP712Message(\n\t\t\tdomainSeparator,\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tCLAIM_TYPEHASH,\n\t\t\t\t\t_claimData.to,\n\t\t\t\t\t_claimData.amount,\n\t\t\t\t\t_claimData.transactionHash,\n\t\t\t\t\t_claimData.originChainId,\n\t\t\t\t\t_relayer,\n\t\t\t\t\t_fee,\n\t\t\t\t\tnonces[_claimData.to]++,\n\t\t\t\t\t_deadline\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t// Inspired by https://github.com/dapphub/ds-dach/blob/master/src/dach.sol\n\tfunction claimGasless(\n\t\tClaimData calldata _claimData,\n\t\taddress payable _relayer,\n\t\tuint256 _fee,\n\t\tuint256 _deadline,\n\t\tuint8 _v,\n\t\tbytes32 _r,\n\t\tbytes32 _s\n\t) external override returns (uint256 receivedAmount) {\n\t\trequire(_deadline >= block.timestamp, \"Bridge: EXPIRED\"); // solhint-disable-line not-rely-on-time\n\n\t\tbytes32 digest = getDigest(_claimData, _relayer, _fee, _deadline);\n\t\taddress recoveredAddress = ecrecover(digest, _v, _r, _s);\n\t\trequire(_claimData.to != address(0) && recoveredAddress == _claimData.to, \"Bridge: INVALID_SIGNATURE\");\n\n\t\treturn _claim(\n\t\t\t_claimData,\n\t\t\t_claimData.to,\n\t\t\t_relayer,\n\t\t\t_fee\n\t\t);\n\t}\n\n\tfunction isClaimed(bytes32 transactionDataHash, bytes32 transactionDataHashMultichain) public view returns(bool) {\n\t\treturn claimed[transactionDataHash] || claimed[transactionDataHashMultichain];\n\t}\n\n\tfunction isClaimed(ClaimData calldata _claimData, bytes32 transactionDataHashMultichain) public view returns(bool) {\n\t\tbytes32 transactionDataHash = getTransactionDataHash(\n\t\t\t_claimData.to,\n\t\t\t_claimData.amount,\n\t\t\t_claimData.blockHash,\n\t\t\t_claimData.transactionHash,\n\t\t\t_claimData.logIndex\n\t\t);\n\n\t\treturn claimed[transactionDataHash] || claimed[transactionDataHashMultichain];\n\t}\n\n\tfunction _claim(\n\t\tClaimData calldata _claimData,\n\t\taddress payable _reciever,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal nonReentrant returns (uint256 receivedAmount) {\n\t\taddress originalTokenAddress = originalTokenAddresses[_claimData.transactionHash];\n\t\trequire(originalTokenAddress != NULL_ADDRESS, \"Bridge: Tx not crossed\");\n\n\t\tbytes32 transactionDataHash = getTransactionDataHash(\n\t\t\t_claimData.to,\n\t\t\t_claimData.amount,\n\t\t\t_claimData.blockHash,\n\t\t\t_claimData.transactionHash,\n\t\t\t_claimData.logIndex,\n\t\t\t_claimData.originChainId,\n\t\t\tblock.chainid\n\t\t);\n\n\t\trequire(transactionsDataHashes[_claimData.transactionHash] == transactionDataHash, \"Bridge: Wrong transactionDataHash\");\n\t\trequire(!isClaimed(_claimData, transactionDataHash), \"Bridge: Already claimed\");\n\t\tclaimed[transactionDataHash] = true;\n\n\t\treceivedAmount = _claimCross(\n\t\t\t_claimData.originChainId,\n\t\t\toriginalTokenAddress,\n\t\t\t_reciever,\n\t\t\t_claimData.amount,\n\t\t\t_relayer,\n\t\t\t_fee\n\t\t);\n\n\t\temitClaimed(_claimData, originalTokenAddress, _reciever, _relayer, _fee);\n\t\treturn receivedAmount;\n\t}\n\n\tfunction emitClaimed(\n\t\tClaimData calldata _claimData,\n\t\taddress _originalTokenAddress,\n\t\taddress payable _reciever,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal {\n\t\temit Claimed(\n\t\t\t_claimData.transactionHash,\n\t\t\t_originalTokenAddress,\n\t\t\t_claimData.to,\n\t\t\tsenderAddresses[_claimData.transactionHash],\n\t\t\t_claimData.amount,\n\t\t\t_claimData.blockHash,\n\t\t\t_claimData.logIndex,\n\t\t\t_reciever,\n\t\t\t_relayer,\n\t\t\t_fee,\n\t\t\t_claimData.originChainId,\n\t\t\tblock.chainid\n\t\t);\n\t}\n\n\tfunction _claimCross(\n\t\tuint256 _originalChainId,\n\t\taddress _originalTokenAddress,\n\t\taddress payable _reciever,\n\t\tuint256 _amount,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal returns (uint256) {\n\t\tcheckChainId(_originalChainId);\n\t\tif (knownToken(_originalChainId, _originalTokenAddress)) {\n\t\t\treturn _claimCrossBackToToken(\n\t\t\t\t_originalTokenAddress,\n\t\t\t\t_reciever,\n\t\t\t\t_amount,\n\t\t\t\t_relayer,\n\t\t\t\t_fee\n\t\t\t);\n\t\t}\n\n\t\treturn _claimCrossToSideToken(\n\t\t\tsideTokenByOriginalToken(_originalChainId, _originalTokenAddress),\n\t\t\t_reciever,\n\t\t\t_amount,\n\t\t\t_relayer,\n\t\t\t_fee\n\t\t);\n\t}\n\n\tfunction _claimCrossToSideToken(\n\t\taddress _sideToken,\n\t\taddress payable _receiver,\n\t\tuint256 _amount,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal returns (uint256 receivedAmount) {\n\t\trequire(_sideToken != NULL_ADDRESS, \"Bridge: side token is null\");\n\t\tuint256 granularity = IERC777(_sideToken).granularity();\n\t\tuint256 formattedAmount = _amount.mul(granularity);\n\t\trequire(_fee <= formattedAmount, \"Bridge: fee too high\");\n\t\treceivedAmount = formattedAmount.sub(_fee);\n\t\tISideToken(_sideToken).mint(_receiver, receivedAmount, \"\", \"\");\n\t\tif (_fee > 0) {\n\t\t\tISideToken(_sideToken).mint(_relayer, _fee, \"\", \"relayer fee\");\n\t\t}\n\t\treturn receivedAmount;\n\t}\n\n\tfunction _claimCrossBackToToken(\n\t\taddress _originalTokenAddress,\n\t\taddress payable _receiver,\n\t\tuint256 _amount,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal returns (uint256 receivedAmount) {\n\t\tuint256 decimals = LibUtils.getDecimals(_originalTokenAddress);\n\t\t//As side tokens are ERC777 they will always have 18 decimals\n\t\tuint256 formattedAmount = _amount.div(uint256(10) ** (18 - decimals));\n\t\trequire(_fee <= formattedAmount, \"Bridge: fee too high\");\n\t\treceivedAmount = formattedAmount.sub(_fee);\n\t\tif (address(wrappedCurrency) == _originalTokenAddress) {\n\t\t\twrappedCurrency.withdraw(formattedAmount);\n\t\t\t_receiver.transfer(receivedAmount);\n\t\t\tif(_fee > 0) {\n\t\t\t\t_relayer.transfer(_fee);\n\t\t\t}\n\t\t} else {\n\t\t\tIERC20(_originalTokenAddress).safeTransfer(_receiver, receivedAmount);\n\t\t\tif(_fee > 0) {\n\t\t\t\tIERC20(_originalTokenAddress).safeTransfer(_relayer, _fee);\n\t\t\t}\n\t\t}\n\t\treturn receivedAmount;\n\t}\n\n\t/**\n\t\t* ERC-20 tokens approve and transferFrom pattern\n\t\t* See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n\t\t*/\n\tfunction receiveTokensTo(uint256 destinationChainId, address tokenToUse, string memory hathorTo, uint256 amount) external override {\n\t\taddress sender = _msgSender();\n\t\t//Transfer the tokens on IERC20, they should be already Approved for the bridge Address to use them\n\t\tIERC20(tokenToUse).safeTransferFrom(sender, address(this), amount);\n\t\tcrossTokens(tokenToUse, sender, hathorTo, amount, \"\", destinationChainId);\n\t}\n\n\t/**\n\t\t* Use network currency and cross it.\n\t\t*/\n\tfunction depositTo(uint256 chainId, string memory hathorTo) external payable override {\n\t\taddress sender = _msgSender();\n\t\trequire(address(wrappedCurrency) != NULL_ADDRESS, \"Bridge: wrappedCurrency empty\");\n\t\twrappedCurrency.deposit{ value: msg.value }();\n\t\tcrossTokens(address(wrappedCurrency), sender, hathorTo, msg.value, \"\", chainId);\n\t}\n\n\t/**\n\t\t* ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n\t\t* See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n\t\t* @param userData it can be 2 options in the first one you can send the receiver and the chain id of the destination\n\t\t* const userData = web3.eth.abi.encodeParameters(\n    *   [\"address\", \"uint256\"],\n    *   [anAccount.toLowerCase(), chains.ETHEREUM_MAIN_NET_CHAIN_ID]\n    * );\n\t\t* or you also can send only the destination chain id, and the receiver would be the same as the from parameter\n\t\t* const userData = web3.eth.abi.encodeParameters([\"uint256\"], [chains.ETHEREUM_MAIN_NET_CHAIN_ID]);\n\t\t*/\n\tfunction tokensReceived(\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint amount,\n\t\tbytes calldata userData, // [address,uint256] user address receiver, destinationChainId || [uint256] same as from, destinationChainId\n\t\tbytes calldata operatorData\n\t) external override(IBridge, IERC777Recipient) {\n\t\t//Hook from ERC777address\n\t\tif(operator == address(this)) return; // Avoid loop from bridge calling to ERC77transferFrom\n\t\trequire(to == address(this), \"Bridge: Not to this address\");\n\t\taddress tokenToUse = _msgSender();\n\t\trequire(ERC1820.getInterfaceImplementer(tokenToUse, _erc777Interface) != NULL_ADDRESS, \"Bridge: Not ERC777 token\");\n\t\trequire(userData.length >= 32, \"Bridge: user data with at least the destinationChainId\");\n\t\trequire(userData.length == 64 || !from.isContract(), \"Bridge: Specify receiver address in data\");\n\t\taddress receiver = userData.length == 32 ? from : LibUtils.toAddress(userData, 12);\n\t\tuint256 destinationChainId = LibUtils.toUint256(userData, userData.length - 32);\n\t\tstring memory hathorTo = \"undefined\";\n\t\tcrossTokens(tokenToUse, from, hathorTo, amount, userData, destinationChainId);\n\t}\n\n\tfunction crossTokens(\n\t\taddress tokenToUse,\n\t\taddress from,\n\t\tstring memory hathorTo,\n\t\tuint256 amount,\n\t\tbytes memory userData,\n\t\tuint256 destinationChainId\n\t) internal whenNotUpgrading whenNotPaused nonReentrant {\n\t\trequire(block.chainid != destinationChainId, \"Bridge: destination chain id equal current chain id\");\n\t\tcheckChainId(destinationChainId);\n\t\t_setKnownTokenByChain(destinationChainId, tokenToUse, true);\n\t\tuint256 fee = amount.mul(feePercentage).div(feePercentageDivider);\n\t\tuint256 amountMinusFees = amount.sub(fee);\n\t\tuint8 decimals = LibUtils.getDecimals(tokenToUse);\n\t\tuint formattedAmount = amount;\n\t\tif (decimals != 18) {\n\t\t\tformattedAmount = amount.mul(uint256(10)**(18-decimals));\n\t\t}\n\t\t// We consider the amount before fees converted to 18 decimals to check the limits\n\t\t// updateTokenTransfer revert if token not allowed\n\t\tallowTokens.updateTokenTransfer(tokenToUse, formattedAmount);\n\n\t\tOriginalToken memory sideToken = getOriginalTokenBySideToken(tokenToUse);\n\t\tif (sideToken.tokenAddress != NULL_ADDRESS) {\n\t\t\t// Side Token Crossing back\n\t\t\t{ // Created scope to avoid stack too deep\n\t\t\t\tuint256 granularity = LibUtils.getGranularity(tokenToUse);\n\t\t\t\tuint256 modulo = amountMinusFees.mod(granularity);\n\t\t\t\tfee = fee.add(modulo);\n\t\t\t\tamountMinusFees = amountMinusFees.sub(modulo);\n\t\t\t\tIERC777(tokenToUse).burn(amountMinusFees, userData);\n\t\t\t}\n\t\t\temit Cross(\n\t\t\t\tsideToken.tokenAddress,\n\t\t\t\thathorTo,\n\t\t\t\tdestinationChainId,\n\t\t\t\tfrom,\n\t\t\t\tblock.chainid,\n\t\t\t\tamountMinusFees,\n\t\t\t\tuserData\n\t\t\t);\n\t\t} else {\n\t\t\temit Cross(\n\t\t\t\ttokenToUse,\n\t\t\t\thathorTo,\n\t\t\t\tdestinationChainId,\n\t\t\t\tfrom,\n\t\t\t\tblock.chainid,\n\t\t\t\tamountMinusFees,\n\t\t\t\tuserData\n\t\t\t);\n\t\t}\n\n\t\tif (fee > 0) {\n\t\t\t//Send the payment to the MultiSig of the Federation\n\t\t\tIERC20(tokenToUse).safeTransfer(owner(), fee);\n\t\t}\n\t}\n\n\t// function for retrocompatibility\n\tfunction getTransactionDataHash(\n\t\taddress _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex\n\t) internal pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(_blockHash, _transactionHash, _to, _amount, _logIndex));\n\t}\n\n\tfunction getTransactionDataHash(\n\t\taddress _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256\t_destinationChainId\n\t) public pure override returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(_blockHash, _transactionHash, _to, _amount, _logIndex, _originChainId, _destinationChainId));\n\t}\n\n\tfunction setFeePercentage(uint amount) external onlyOwner {\n\t\trequire(amount < (feePercentageDivider/10), \"Bridge: bigger than 10%\");\n\t\tfeePercentage = amount;\n\t\temit FeePercentageChanged(feePercentage);\n\t}\n\n\tfunction getFeePercentage() external view override returns(uint) {\n\t\treturn feePercentage;\n\t}\n\n\tfunction changeFederation(address newFederation) external onlyOwner {\n\t\trequire(newFederation != NULL_ADDRESS, \"Bridge: Federation is empty\");\n\t\trequire(newFederation.isContract(), \"Bridge: Federation not a contract\");\n\t\tfederation = newFederation;\n\t\temit FederationChanged(federation);\n\t}\n\n\tfunction changeAllowTokens(address newAllowTokens) external onlyOwner {\n\t\trequire(newAllowTokens != NULL_ADDRESS, \"Bridge: AllowTokens is empty\");\n\t\trequire(newAllowTokens.isContract(), \"Bridge: Allow Tokens not a contract\");\n\t\tallowTokens = IAllowTokens(newAllowTokens);\n\t\temit AllowTokensChanged(newAllowTokens);\n\t}\n\n\tfunction getFederation() external view returns(address) {\n\t\treturn federation;\n\t}\n\n\tfunction changeSideTokenFactory(address newSideTokenFactory) external onlyOwner {\n\t\trequire(newSideTokenFactory != NULL_ADDRESS, \"Bridge: SideTokenFactory is empty\");\n\t\trequire(newSideTokenFactory.isContract(), \"Bridge: SideTokenFactory not a contract\");\n\t\tsideTokenFactory = ISideTokenFactory(newSideTokenFactory);\n\t\temit SideTokenFactoryChanged(newSideTokenFactory);\n\t}\n\n\tfunction setUpgrading(bool _isUpgrading) external onlyOwner {\n\t\tisUpgrading = _isUpgrading;\n\t\temit Upgrading(isUpgrading);\n\t}\n\n\tfunction setWrappedCurrency(address _wrappedCurrency) external onlyOwner {\n\t\trequire(_wrappedCurrency != NULL_ADDRESS, \"Bridge: wrapp is empty\");\n\t\twrappedCurrency = IWrapped(_wrappedCurrency);\n\t\temit WrappedCurrencyChanged(_wrappedCurrency);\n\t}\n\n\tfunction hasCrossed(bytes32 transactionHash) public view returns (bool) {\n\t\treturn transactionsDataHashes[transactionHash] != bytes32(0);\n\t}\n\n\tfunction hasBeenClaimed(bytes32 transactionHash) public view returns (bool) {\n\t\treturn claimed[transactionsDataHashes[transactionHash]];\n\t}\n\n\tfunction uidToAddress (string calldata uid) public pure  returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(uid));\n        return address(uint160(bytes20(hash)));\n    }\n\n\tfunction addHathorToken(uint256 originalChainId, address token, string memory uid) public onlyOwner {\n\t\tEvmToHathorTokenMap[token] = uid;\n\t\tHathorToEvmTokenMap[uid] = OriginalToken(token, originalChainId);\n\t\temit HathorTokenMapped(token, uid);\n\t}\n\n}\n"
    },
    "contracts/interface/IAllowTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\ninterface IAllowTokens {\n\n\tstruct Limits {\n\t\tuint256 min;\n\t\tuint256 max;\n\t\tuint256 daily;\n\t\tuint256 mediumAmount;\n\t\tuint256 largeAmount;\n\t}\n\n\tstruct TokenInfo {\n\t\tbool allowed;\n\t\tuint256 typeId;\n\t\tuint256 spentToday;\n\t\tuint256 lastDay;\n\t}\n\n\tstruct TypeInfo {\n\t\tstring description;\n\t\tLimits limits;\n\t}\n\n\tstruct TokensAndType {\n\t\taddress token;\n\t\tuint256 typeId;\n\t}\n\n\tfunction version() external pure returns (string memory);\n\n\tfunction getInfoAndLimits(address token) external view returns (TokenInfo memory info, Limits memory limit);\n\n\tfunction calcMaxWithdraw(address token) external view returns (uint256 maxWithdraw);\n\n\tfunction getTypesLimits() external view returns(Limits[] memory limits);\n\n\tfunction getTypeDescriptionsLength() external view returns(uint256);\n\n\tfunction getTypeDescriptions() external view returns(string[] memory descriptions);\n\n\tfunction setToken(address token, uint256 typeId) external;\n\n\tfunction getConfirmations() external view returns (uint256 smallAmount, uint256 mediumAmount, uint256 largeAmount);\n\n\tfunction isTokenAllowed(address token) external view returns (bool);\n\n\tfunction updateTokenTransfer(address token, uint256 amount) external;\n}"
    },
    "contracts/interface/IBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\ninterface IBridge {\n\n\tstruct ClaimData {\n\t\taddress payable to;\n\t\tuint256 amount;\n\t\tbytes32 blockHash;\n\t\tbytes32 transactionHash;\n\t\tuint32 logIndex;\n\t\tuint256 originChainId;\n\t}\n\n\tstruct OriginalToken {\n\t\taddress tokenAddress;\n\t\tuint256 originChainId;\n\t}\n\t\n\tstruct CreateSideTokenStruct {\n\t\tuint256 _typeId;\n\t\taddress _originalTokenAddress;\n\t\tuint8 _originalTokenDecimals;\n\t\tstring _originalTokenSymbol;\n\t\tstring _originalTokenName;\n\t\tuint256 _originChainId;\n\t}\n\n\tfunction version() external pure returns (string memory);\n\n\tfunction getFeePercentage() external view returns(uint);\n\n\t/**\n\t\t* ERC-20 tokens approve and transferFrom pattern\n\t\t* See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n\t\t*/\n\tfunction receiveTokensTo(uint256 chainId, address tokenToUse, string memory hathorTo, uint256 amount) external;\n\n\t/**\n\t\t* Use network currency and cross it.\n\t\t*/\n\tfunction depositTo(uint256 chainId, string memory hathorTo) external payable;\n\n\t/**\n\t\t* ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n\t\t* See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n\t\t* @param userData it can be 2 options in the first one you can send the receiver and the chain id of the destination\n\t\t* const userData = web3.eth.abi.encodeParameters(\n    *   [\"address\", \"uint256\"],\n    *   [anAccount.toLowerCase(), chains.ETHEREUM_MAIN_NET_CHAIN_ID]\n    * );\n\t\t* or you also can send only the destination chain id, and the receiver would be the same as the from parameter\n\t\t* const userData = web3.eth.abi.encodeParameters([\"uint256\"], [chains.ETHEREUM_MAIN_NET_CHAIN_ID]);\n\t\t*/\n\tfunction tokensReceived (\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint amount,\n\t\tbytes calldata userData,\n\t\tbytes calldata operatorData\n\t) external;\n\n\t/**\n\t\t* Accepts the transaction from the other chain that was voted and sent by the Federation contract\n\t\t*/\n\tfunction acceptTransfer(\n\t\taddress _originalTokenAddress,\n\t\taddress payable _from,\n\t\taddress payable _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256\t_destinationChainId\n\t) external;\n\n\t/**\n\t\t* Claims the crossed transaction using the hash, this sends the funds to the address indicated in\n\t\t*/\n\tfunction claim(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\n\n\tfunction claimFallback(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\n\n\tfunction claimGasless(\n\t\tClaimData calldata _claimData,\n\t\taddress payable _relayer,\n\t\tuint256 _fee,\n\t\tuint256 _deadline,\n\t\tuint8 _v,\n\t\tbytes32 _r,\n\t\tbytes32 _s\n\t) external returns (uint256 receivedAmount);\n\n\tfunction createSideToken(\n\t\tuint256 _typeId,\n\t\taddress _originalTokenAddress,\n\t\tuint8 _originalTokenDecimals,\n\t\tstring calldata _originalTokenSymbol,\n\t\tstring calldata _originalTokenName,\n\t\tuint256 _chainId\n\t) external;\n\n\tfunction createMultipleSideTokens(\n\t\tCreateSideTokenStruct[] calldata createSideTokenStruct\n\t) external;\n\n\tfunction getTransactionDataHash(\n\t\taddress _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256 _destinationChainId\n\t) external returns(bytes32);\n\n\tevent Cross(\n\t\taddress indexed _tokenAddress,\n\t\tstring _to,\n\t\tuint256 indexed _destinationChainId,\n\t\taddress _from,\n\t\tuint256 _originChainId,\n\t\tuint256 _amount,\n\t\tbytes _userData\n\t);\n\n\tevent NewSideToken(\n\t\taddress indexed _newSideTokenAddress,\n\t\taddress indexed _originalTokenAddress,\n\t\tstring _newSymbol,\n\t\tuint256 _granularity,\n\t\tuint256 _chainId\n\t);\n\tevent AcceptedCrossTransfer(\n\t\tbytes32 indexed _transactionHash,\n\t\taddress indexed _originalTokenAddress,\n\t\taddress indexed _to,\n\t\taddress  _from,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tuint256 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256\t_destinationChainId\n\t);\n\tevent FeePercentageChanged(uint256 _amount);\n\tevent Claimed(\n\t\tbytes32 indexed _transactionHash,\n\t\taddress indexed _originalTokenAddress,\n\t\taddress indexed _to,\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tuint256 _logIndex,\n\t\taddress _reciever,\n\t\taddress _relayer,\n\t\tuint256 _fee,\n\t\tuint256 _destinationChainId,\n\t\tuint256 _originChainId\n\t);\n}"
    },
    "contracts/interface/ISideToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\ninterface ISideToken {\n    function mint(address account, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;\n}"
    },
    "contracts/interface/ISideTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\ninterface ISideTokenFactory {\n\n    function createSideToken(string calldata name, string calldata symbol, uint256 granularity) external returns(address);\n\n    event SideTokenCreated(address indexed sideToken, string symbol, uint256 granularity);\n}"
    },
    "contracts/interface/IWrapped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\ninterface IWrapped {\n    function balanceOf(address) external returns(uint);\n\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n\n    function totalSupply() external view returns (uint);\n\n    function approve(address guy, uint wad) external returns (bool);\n\n    function transfer(address dst, uint wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint wad)\n        external\n        returns (bool);\n}"
    },
    "contracts/lib/LibEIP712.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n// https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\nlibrary LibEIP712 {\n\n    // Hash of the EIP712 Domain Separator Schema\n    // keccak256(abi.encodePacked(\n    //     \"EIP712Domain(\",\n    //     \"string name,\",\n    //     \"string version,\",\n    //     \"uint256 chainId,\",\n    //     \"address verifyingContract\",\n    //     \")\"\n    // ))\n    bytes32 constant internal _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev Calculates a EIP712 domain separator.\n    /// @param name The EIP712 domain name.\n    /// @param version The EIP712 domain version.\n    /// @param verifyingContract The EIP712 verifying contract.\n    /// @return result EIP712 domain separator.\n    function hashEIP712Domain(\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    )\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n        //     keccak256(bytes(name)),\n        //     keccak256(bytes(version)),\n        //     chainId,\n        //     uint256(verifyingContract)\n        // ))\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Calculate hashes of dynamic data\n            let nameHash := keccak256(add(name, 32), mload(name))\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            // Store params in memory\n            mstore(memPtr, schemaHash)\n            mstore(add(memPtr, 32), nameHash)\n            mstore(add(memPtr, 64), versionHash)\n            mstore(add(memPtr, 96), chainId)\n            mstore(add(memPtr, 128), verifyingContract)\n\n            // Compute hash\n            result := keccak256(memPtr, 160)\n        }\n        return result;\n    }\n\n    /// @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\n    /// @param eip712DomainHash Hash of the domain domain separator data, computed\n    ///                         with getDomainHash().\n    /// @param hashStruct The EIP712 hash struct.\n    /// @return result EIP712 hash applied to the given EIP712 Domain.\n    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     EIP191_HEADER,\n        //     EIP712_DOMAIN_HASH,\n        //     hashStruct\n        // ));\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n            // Compute hash\n            result := keccak256(memPtr, 66)\n        }\n        return result;\n    }\n}"
    },
    "contracts/lib/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\nlibrary LibUtils {\n\n    function decimalsToGranularity(uint8 decimals) internal pure returns (uint256) {\n        require(decimals <= 18, \"LibUtils: Decimals not <= 18\");\n        return uint256(10)**(18-decimals);\n    }\n\n    function getDecimals(address tokenToUse) internal view returns (uint8) {\n        //support decimals as uint256 or uint8\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        require(success, \"LibUtils: No decimals\");\n        // uint<M>: enc(X) is the big-endian encoding of X,\n        uint8 decimals = uint8(abi.decode(data, (uint256)));\n        require(decimals >= 0 || decimals <=18,\"LibUtils: out of range\");\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\n        return decimals;\n    }\n\n    function getGranularity(address tokenToUse) internal view returns (uint256) {\n        //support granularity if ERC777\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"granularity()\"));\n        require(success, \"LibUtils: No granularity\");\n\n        return abi.decode(data, (uint256));\n    }\n\n    function bytesToAddress(bytes memory bys) internal pure returns (address addr) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            addr := mload(add(bys,20))\n        }\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"LibUtils: toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"LibUtils: toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n\t\trequire(_bytes.length >= _start + 32, \"LibUtils: toUint256_outOfBounds\");\n\t\tuint256 tempUint;\n\n        // solium-disable-next-line security/no-inline-assembly\n\t\tassembly {\n\t\t\ttempUint := mload(add(add(_bytes, 0x20), _start))\n\t\t}\n\n\t\treturn tempUint;\n\t}\n}\n"
    },
    "contracts/test/LibUtilsHarness.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../lib/LibUtils.sol\";\n\ncontract LibUtilsHarness {\n\n    function decimalsToGranularity(uint8 decimals) external pure returns (uint256) {\n        return LibUtils.decimalsToGranularity(decimals);\n    }\n\n    function getDecimals(address tokenToUse) external view returns (uint8) {\n        return LibUtils.getDecimals(tokenToUse);\n    }\n\n    function getGranularity(address tokenToUse) external view returns (uint256) {\n        return LibUtils.getGranularity(tokenToUse);\n    }\n\n    function bytesToAddress(bytes memory bys) external pure returns (address addr) {\n        return LibUtils.bytesToAddress(bys);\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) external pure returns (uint128) {\n        return LibUtils.toUint128(_bytes, _start);\n    }\n\n}\n"
    },
    "contracts/zeppelin/access/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account doesn't have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "contracts/zeppelin/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract  Context {\n\n    function _msgSender() internal view returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/zeppelin/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as `account`'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `_account`.\n     * - `_interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `_implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address _account, bytes32 _interfaceHash, address _implementer) external;\n\n    /**\n     * @dev Returns the implementer of `_interfaceHash` for `_account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `_interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `_account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address _account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "contracts/zeppelin/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/zeppelin/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See `IERC1820Registry` and\n * `ERC1820Implementer`.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n     *\n     * Emits a `Sent` event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See `IERC777Sender`.\n     *\n     * Emits a `Burned` event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See `operatorSend` and `operatorBurn`.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See `isOperatorFor`.\n     *\n     * Emits an `AuthorizedOperator` event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See `isOperatorFor` and `defaultOperators`.\n     *\n     * Emits a `RevokedOperator` event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if `authorizeOperator` was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * `revokeOperator`, in which case `isOperatorFor` will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n     *\n     * Emits a `Sent` event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See `IERC777Sender`.\n     *\n     * Emits a `Burned` event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    function decimals() external returns (uint8);\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of `IERC777` tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\n *\n * See `IERC1820Registry` and `ERC1820Implementer`.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an `IERC777` token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * `IERC777.balanceOf`, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "contracts/zeppelin/upgradable/access/roles/UpgradablePauserRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\nimport \"../../Initializable.sol\";\n\nimport \"../../../GSN/Context.sol\";\nimport \"../../../access/Roles.sol\";\n\ncontract UpgradablePauserRole is Initializable, Context {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    function __PauserRol_init(address sender) public initializer {\n        if (!isPauser(sender)) {\n            _addPauser(sender);\n        }\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(_msgSender()), \"PauserRole: caller doesn't have the role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(_msgSender());\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || !initialized, \"Contract instance is already initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}"
    },
    "contracts/zeppelin/upgradable/lifecycle/UpgradablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"../access/roles/UpgradablePauserRole.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract UpgradablePausable is Initializable, Context, UpgradablePauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    function __Pausable_init(address sender) public initializer {\n        UpgradablePauserRole.__PauserRol_init(sender);\n\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/ownership/UpgradableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract UpgradableOwnable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n}\n"
    },
    "contracts/zeppelin/upgradable/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard is Initializable {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    function initialize() public initializer {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: no reentrant allowed\");\n    }\n}"
    },
    "contracts/zeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}